from django.db.models.aggregates import Aggregate

__all__ = [
    'ArrayAgg', 'BitAnd', 'BitOr', 'BoolAnd', 'BoolOr', 'StringAgg',
]


class OrderableAgg(Aggregate):
    template = "%(function)s(%(expressions)s %(ordering)s)"

    def __init__(self, expression, ordering=None, **extra):
        if not isinstance(ordering, list) and ordering is not None:
            ordering = [ordering]

        super(OrderableAgg, self).__init__(
            expression,
            ordering=ordering,
            **extra
        )

    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
        # resolve the ordering if it's there
        ordering = self.extra.pop('ordering', None)
        if ordering is not None:
            # TODO: remove comments
            # parse, so that string-based orderings are also supported
            parsed_orderings = [self._parse_expressions(an_ordering)[0] for an_ordering in ordering]
            resolved_ordering = [parsed_ordering.resolve_expression(query, allow_joins, reuse, summarize) for parsed_ordering in parsed_orderings]

            self.extra['ordering'] = resolved_ordering

        return super(OrderableAgg, self).resolve_expression(query, allow_joins, reuse, summarize, for_save)

    def as_sql(self, compiler, connection):
        # turn ordering parameter to ORDER BY sql clause
        if 'ordering' in self.extra:
            ordering_sql = [ordering_element.as_sql(compiler, connection)[0] for ordering_element in self.extra['ordering']]
            self.extra['ordering'] = 'ORDER BY ' + ', '.join(ordering_sql)
        else:
            self.extra['ordering'] = ''

        return super(OrderableAgg, self).as_sql(compiler, connection)

    def get_source_expressions(self):
        #TODO check how this is supposed to work
#        print("=========")
#        print(self.extra['ordering'])
#        print(type(self.extra['ordering']))
#        print("=========")
        return self.source_expressions + self.extra['ordering']

#        return (self.source_expressions, *tuple(self.extra['ordering']))

#    def set_source_expressions(self, exprs):
        #TODO check how this is supposed to work
#        self.expression, self.extra['ordering'] = exprs[0], exprs[1:]


class ArrayAgg(OrderableAgg):
    function = 'ARRAY_AGG'

    def convert_value(self, value, expression, connection, context):
        if not value:
            return []
        return value


class BitAnd(Aggregate):
    function = 'BIT_AND'


class BitOr(Aggregate):
    function = 'BIT_OR'


class BoolAnd(Aggregate):
    function = 'BOOL_AND'


class BoolOr(Aggregate):
    function = 'BOOL_OR'


class StringAgg(OrderableAgg):
    function = 'STRING_AGG'
    template = "%(function)s(%(distinct)s%(expressions)s, '%(delimiter)s'%(ordering)s)"

    def __init__(self, expression, delimiter, distinct=False, **extra):
        distinct = 'DISTINCT ' if distinct else ''
        super(StringAgg, self).__init__(expression, delimiter=delimiter, distinct=distinct, **extra)

    def convert_value(self, value, expression, connection, context):
        if not value:
            return ''
        return value
